<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Inspector Graph</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- D3.js v7.8.5 - downloaded from https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js -->
  <script src="d3.min.js"></script>
  <style>
    html, body { margin: 0; height: 100%; width: 100%; font-family: Arial, sans-serif; overflow: hidden; }
    .container { display: flex; height: 100%; }
    .sidebar {
      width: 300px;
      background: #f5f5f5;
      border-right: 1px solid #ddd;
      overflow-y: auto;
      padding: 0;
      display: flex;
      flex-direction: column;
    }
    .sidebar h3 {
      margin: 0;
      padding: 15px 20px;
      background: #333;
      color: white;
      font-size: 16px;
      border-bottom: 1px solid #555;
    }
    .node-list {
      list-style: none;
      margin: 0;
      padding: 0;
      flex: 1;
      overflow-y: auto;
    }
    .node-item {
      padding: 10px 20px;
      border-bottom: 1px solid #e0e0e0;
      cursor: pointer;
      transition: background 0.2s;
    }
    .node-item:hover {
      background: #e8e8e8;
    }
    .node-item .node-id {
      font-weight: bold;
      color: #333;
    }
    .node-item .node-details {
      font-size: 12px;
      color: #666;
      margin-top: 4px;
    }
    .node-item .node-type {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
      font-weight: bold;
      text-transform: uppercase;
      margin-left: 8px;
    }
    .node-item .node-type.node { background: #4CAF50; color: white; }
    .node-item .node-type.gate { background: #2196F3; color: white; }
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .tabs {
      display: flex;
      background: #333;
      padding: 0;
    }
    .tab {
      padding: 12px 24px;
      background: #444;
      color: #ccc;
      border: none;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    .tab:hover {
      background: #555;
    }
    .tab.active {
      background: #fff;
      color: #333;
    }
    .view-container {
      flex: 1;
      position: relative;
      overflow: hidden;
    }
    .view {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
    }
    .view.active {
      display: block;
    }
    #graph-container, #nodes-graph-container {
      width: 100%;
      height: 100%;
      background: #fafafa;
    }
    #graph-container svg, #nodes-graph-container svg {
      width: 100%;
      height: 100%;
    }
    .nodes-zoom-controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
    }
    .object-count-badge {
      font-size: 14px;
      fill: white;
      font-weight: bold;
      pointer-events: none;
      text-anchor: middle;
      dominant-baseline: central;
    }
    .tooltip {
      position: absolute;
      padding: 10px 14px;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      border-radius: 6px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 1000;
      max-width: 300px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .tooltip.visible {
      opacity: 1;
    }
    .tooltip .tooltip-title {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 6px;
      border-bottom: 1px solid rgba(255,255,255,0.3);
      padding-bottom: 6px;
    }
    .tooltip .tooltip-row {
      margin: 4px 0;
    }
    .tooltip .tooltip-label {
      color: #aaa;
    }
    .graph-node {
      cursor: pointer;
    }
    .graph-node:hover {
      filter: brightness(1.2);
    }
    .graph-link {
      stroke: #999;
      stroke-opacity: 0.6;
    }
    .node-label {
      font-size: 14px;
      fill: #333;
      pointer-events: none;
      text-anchor: middle;
    }
    #shard-container {
      padding: 20px;
      overflow-y: auto;
      background: #fff;
    }
    .shard-chart {
      margin-bottom: 30px;
    }
    .shard-chart h4 {
      margin: 0 0 15px 0;
      color: #333;
    }
    .shard-bar-container {
      display: flex;
      flex-wrap: wrap;
      gap: 2px;
    }
    .shard-bar {
      height: 24px;
      min-width: 4px;
      border-radius: 2px;
      transition: all 0.3s;
      cursor: pointer;
    }
    .shard-bar:hover {
      filter: brightness(1.2);
      transform: scaleY(1.2);
    }
    .shard-stats {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .stat-card {
      background: #f5f5f5;
      padding: 15px 20px;
      border-radius: 8px;
      min-width: 120px;
    }
    .stat-card .stat-value {
      font-size: 28px;
      font-weight: bold;
      color: #333;
    }
    .stat-card .stat-label {
      font-size: 12px;
      color: #666;
      margin-top: 4px;
    }
    .legend {
      display: flex;
      gap: 20px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
    }
    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 3px;
    }
    .shard-distribution-container {
      display: flex;
      flex-wrap: wrap;
      gap: 2px;
    }
    .shard-range-label {
      margin-top: 8px;
      font-size: 12px;
      color: #666;
    }
    .pie-chart-container {
      display: flex;
      align-items: flex-start;
      gap: 20px;
    }
    .pie-chart-svg {
      flex-shrink: 0;
    }
    .pie-chart-legend {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .zoom-controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 100;
    }
    .zoom-btn {
      width: 36px;
      height: 36px;
      border: none;
      background: white;
      border-radius: 6px;
      font-size: 18px;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: background 0.2s;
    }
    .zoom-btn:hover {
      background: #f0f0f0;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="sidebar">
      <h3>Cluster Nodes</h3>
      <ul id="node-list" class="node-list"></ul>
    </div>
    <div class="main-content">
      <div class="tabs">
        <button class="tab active" data-view="graph">Objects View</button>
        <button class="tab" data-view="nodes">Nodes View</button>
        <button class="tab" data-view="shard">Shard Distribution</button>
      </div>
      <div class="view-container">
        <div id="graph-view" class="view active">
          <div id="graph-container"></div>
          <div class="zoom-controls">
            <button class="zoom-btn" id="zoom-in">+</button>
            <button class="zoom-btn" id="zoom-out">−</button>
            <button class="zoom-btn" id="zoom-reset">⟲</button>
          </div>
        </div>
        <div id="nodes-view" class="view">
          <div id="nodes-graph-container"></div>
          <div class="zoom-controls nodes-zoom-controls">
            <button class="zoom-btn" id="nodes-zoom-in">+</button>
            <button class="zoom-btn" id="nodes-zoom-out">−</button>
            <button class="zoom-btn" id="nodes-zoom-reset">⟲</button>
          </div>
        </div>
        <div id="shard-view" class="view">
          <div id="shard-container"></div>
        </div>
      </div>
    </div>
  </div>
  <div class="tooltip" id="tooltip"></div>

  <script>
    // Node type constants
    const NODE_TYPE_NODE = 'node'
    const NODE_TYPE_GATE = 'gate'
    const NODE_TYPE_OBJECT = 'object'

    // Animation constants
    const SIMULATION_ALPHA_FULL = 0.3      // Alpha for full graph updates
    const SIMULATION_ALPHA_INCREMENTAL = 0.1 // Alpha for incremental updates (lower = less disruption)
    const SSE_RECONNECT_DELAY = 3000       // SSE reconnect delay in milliseconds

    // Pie chart dimensions
    const PIE_CHART_SIZE = 200

    // Type colors for nodes and objects
    const typeColors = {
      node: '#4CAF50',
      gate: '#2196F3',
      Counter: '#FF9800',
      ChatRoom: '#9C27B0',
      Player: '#E91E63',
      GameSession: '#00BCD4',
      Inventory: '#795548',
      Leaderboard: '#607D8B',
      default: '#999'
    }

    // State
    let graphData = { goverse_nodes: [], goverse_gates: [], goverse_objects: [] }
    let simulation = null
    let svg = null
    let g = null
    let zoom = null

    // Nodes view state
    let nodesSimulation = null
    let nodesSvg = null
    let nodesG = null
    let nodesZoom = null
    let nodesViewInitialized = false

    // Helper function to upsert a node in the goverse_nodes array
    function upsertNode(node) {
      const existingIdx = graphData.goverse_nodes.findIndex(n => n.id === node.id)
      if (existingIdx >= 0) {
        graphData.goverse_nodes[existingIdx] = node
      } else {
        graphData.goverse_nodes.push(node)
      }
    }

    // Helper function to upsert a gate in the goverse_gates array
    function upsertGate(gate) {
      const existingIdx = graphData.goverse_gates.findIndex(g => g.id === gate.id)
      if (existingIdx >= 0) {
        graphData.goverse_gates[existingIdx] = gate
      } else {
        graphData.goverse_gates.push(gate)
      }
    }

    // Helper function to upsert an object in the goverse_objects array
    function upsertObject(obj) {
      const existingIdx = graphData.goverse_objects.findIndex(o => o.id === obj.id)
      if (existingIdx >= 0) {
        graphData.goverse_objects[existingIdx] = obj
      } else {
        graphData.goverse_objects.push(obj)
      }
    }

    // Initialize D3 graph
    function initGraph() {
      const container = document.getElementById('graph-container')
      const width = container.clientWidth
      const height = container.clientHeight

      svg = d3.select('#graph-container')
        .append('svg')
        .attr('width', width)
        .attr('height', height)

      // Add zoom behavior
      zoom = d3.zoom()
        .scaleExtent([0.1, 4])
        .on('zoom', (event) => {
          g.attr('transform', event.transform)
        })

      svg.call(zoom)

      // Main group for zoom/pan
      g = svg.append('g')

      // Links group
      g.append('g').attr('class', 'links')

      // Nodes group
      g.append('g').attr('class', 'nodes')

      // Labels group
      g.append('g').attr('class', 'labels')

      // Initialize force simulation
      simulation = d3.forceSimulation()
        .force('charge', d3.forceManyBody().strength(-200))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(d => getNodeRadius(d) + 5))
        .force('link', d3.forceLink().id(d => d.id).distance(100))
        .on('tick', ticked)

      // Handle window resize
      window.addEventListener('resize', () => {
        const newWidth = container.clientWidth
        const newHeight = container.clientHeight
        svg.attr('width', newWidth).attr('height', newHeight)
        simulation.force('center', d3.forceCenter(newWidth / 2, newHeight / 2))
        simulation.alpha(0.3).restart()

        // Also resize nodes view if initialized
        if (nodesViewInitialized && nodesSvg) {
          const nodesContainer = document.getElementById('nodes-graph-container')
          const nodesWidth = nodesContainer.clientWidth
          const nodesHeight = nodesContainer.clientHeight
          nodesSvg.attr('width', nodesWidth).attr('height', nodesHeight)
          nodesSimulation.force('center', d3.forceCenter(nodesWidth / 2, nodesHeight / 2))
          nodesSimulation.alpha(0.3).restart()
        }
      })

      // Zoom controls
      document.getElementById('zoom-in').addEventListener('click', () => {
        svg.transition().duration(300).call(zoom.scaleBy, 1.3)
      })
      document.getElementById('zoom-out').addEventListener('click', () => {
        svg.transition().duration(300).call(zoom.scaleBy, 0.7)
      })
      document.getElementById('zoom-reset').addEventListener('click', () => {
        svg.transition().duration(300).call(zoom.transform, d3.zoomIdentity)
      })
    }

    // Initialize Nodes-only view
    function initNodesView() {
      if (nodesViewInitialized) return
      nodesViewInitialized = true

      const container = document.getElementById('nodes-graph-container')
      const width = container.clientWidth || 800
      const height = container.clientHeight || 600

      nodesSvg = d3.select('#nodes-graph-container')
        .append('svg')
        .attr('width', width)
        .attr('height', height)

      // Add zoom behavior
      nodesZoom = d3.zoom()
        .scaleExtent([0.1, 4])
        .on('zoom', (event) => {
          nodesG.attr('transform', event.transform)
        })

      nodesSvg.call(nodesZoom)

      // Main group for zoom/pan
      nodesG = nodesSvg.append('g')

      // Links group (must be before nodes so links appear behind)
      nodesG.append('g').attr('class', 'nodes-only-links')

      // Nodes group
      nodesG.append('g').attr('class', 'nodes-only-nodes')

      // Labels group
      nodesG.append('g').attr('class', 'nodes-only-labels')

      // Initialize force simulation for nodes only
      nodesSimulation = d3.forceSimulation()
        .force('charge', d3.forceManyBody().strength(-150))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(50))
        .force('link', d3.forceLink().id(d => d.id).distance(150).strength(0.5))
        .on('tick', nodesViewTicked)

      // Zoom controls for nodes view
      document.getElementById('nodes-zoom-in').addEventListener('click', () => {
        nodesSvg.transition().duration(300).call(nodesZoom.scaleBy, 1.3)
      })
      document.getElementById('nodes-zoom-out').addEventListener('click', () => {
        nodesSvg.transition().duration(300).call(nodesZoom.scaleBy, 0.7)
      })
      document.getElementById('nodes-zoom-reset').addEventListener('click', () => {
        nodesSvg.transition().duration(300).call(nodesZoom.transform, d3.zoomIdentity)
      })
    }

    function nodesViewTicked() {
      // Update link positions
      nodesG.select('.nodes-only-links').selectAll('.nodes-link')
        .attr('x1', d => d.source.x)
        .attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x)
        .attr('y2', d => d.target.y)

      // Update node positions
      nodesG.select('.nodes-only-nodes').selectAll('.graph-node')
        .attr('transform', d => `translate(${d.x}, ${d.y})`)

      // Update label positions
      nodesG.select('.nodes-only-labels').selectAll('.node-label')
        .attr('x', d => d.x)
        .attr('y', d => d.y + 50)
    }

    function getNodeRadius(d) {
      if (d.nodeType === NODE_TYPE_NODE) return 25
      if (d.nodeType === NODE_TYPE_GATE) return 22
      return d.size ? Math.max(8, Math.min(20, d.size / 2)) : 12
    }

    function getNodeColor(d) {
      if (d.nodeType === NODE_TYPE_NODE) return typeColors.node
      if (d.nodeType === NODE_TYPE_GATE) return typeColors.gate
      return d.color || typeColors[d.type] || typeColors.default
    }

    function getNodeShape(d) {
      if (d.nodeType === NODE_TYPE_NODE) return 'square'
      if (d.nodeType === NODE_TYPE_GATE) return 'diamond'
      return 'circle'
    }

    function ticked() {
      // Update node positions
      g.select('.nodes').selectAll('.graph-node')
        .attr('transform', d => `translate(${d.x}, ${d.y})`)

      // Update label positions
      g.select('.labels').selectAll('.node-label')
        .attr('x', d => d.x)
        .attr('y', d => d.y + getNodeRadius(d) + 14)

      // Update link positions
      g.select('.links').selectAll('.graph-link')
        .attr('x1', d => d.source.x)
        .attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x)
        .attr('y2', d => d.target.y)
    }

    function updateGraph() {
      // Build nodes array: cluster nodes/gates + objects
      const nodes = []
      const links = []
      const nodeMap = new Map()

      // Add cluster nodes
      graphData.goverse_nodes.forEach(n => {
        const node = {
          id: n.id,
          label: n.label || n.id,
          nodeType: NODE_TYPE_NODE,
          advertiseAddr: n.advertise_addr,
          color: n.color
        }
        nodes.push(node)
        nodeMap.set(n.id, node)
      })

      // Add gates
      graphData.goverse_gates.forEach(g => {
        const node = {
          id: g.id,
          label: g.label || g.id,
          nodeType: NODE_TYPE_GATE,
          advertiseAddr: g.advertise_addr,
          color: g.color
        }
        nodes.push(node)
        nodeMap.set(g.id, node)
      })

      // Add objects
      graphData.goverse_objects.forEach(obj => {
        const node = {
          id: obj.id,
          label: obj.label || obj.id,
          nodeType: NODE_TYPE_OBJECT,
          type: obj.type,
          shardId: obj.shard_id,
          goverseNodeId: obj.goverse_node_id,
          color: obj.color,
          size: obj.size
        }
        nodes.push(node)
        nodeMap.set(obj.id, node)

        // Create link from object to its node
        if (obj.goverse_node_id && nodeMap.has(obj.goverse_node_id)) {
          links.push({
            source: obj.id,
            target: obj.goverse_node_id
          })
        }
      })

      // Update simulation
      simulation.nodes(nodes)
      simulation.force('link').links(links)

      // Update links
      const linkSelection = g.select('.links')
        .selectAll('.graph-link')
        .data(links, d => `${d.source.id || d.source}-${d.target.id || d.target}`)

      linkSelection.exit().remove()

      linkSelection.enter()
        .append('line')
        .attr('class', 'graph-link')
        .attr('stroke-width', 1.5)

      // Update nodes
      const nodeSelection = g.select('.nodes')
        .selectAll('.graph-node')
        .data(nodes, d => d.id)

      nodeSelection.exit().remove()

      const nodeEnter = nodeSelection.enter()
        .append('g')
        .attr('class', 'graph-node')
        .call(d3.drag()
          .on('start', dragStarted)
          .on('drag', dragged)
          .on('end', dragEnded))
        .on('mouseover', showTooltip)
        .on('mousemove', moveTooltip)
        .on('mouseout', hideTooltip)

      // Add shapes based on node type
      nodeEnter.each(function(d) {
        const el = d3.select(this)
        const r = getNodeRadius(d)
        const shape = getNodeShape(d)

        if (shape === 'square') {
          el.append('rect')
            .attr('width', r * 2)
            .attr('height', r * 2)
            .attr('x', -r)
            .attr('y', -r)
            .attr('rx', 4)
            .attr('fill', getNodeColor(d))
        } else if (shape === 'diamond') {
          el.append('polygon')
            .attr('points', `0,${-r} ${r},0 0,${r} ${-r},0`)
            .attr('fill', getNodeColor(d))
        } else {
          el.append('circle')
            .attr('r', r)
            .attr('fill', getNodeColor(d))
        }
      })

      // Update existing node colors
      nodeSelection.each(function(d) {
        const el = d3.select(this)
        const shape = getNodeShape(d)
        if (shape === 'square') {
          el.select('rect').attr('fill', getNodeColor(d))
        } else if (shape === 'diamond') {
          el.select('polygon').attr('fill', getNodeColor(d))
        } else {
          el.select('circle').attr('fill', getNodeColor(d))
        }
      })

      // Update labels
      const labelSelection = g.select('.labels')
        .selectAll('.node-label')
        .data(nodes.filter(d => d.nodeType === NODE_TYPE_NODE || d.nodeType === NODE_TYPE_GATE), d => d.id)

      labelSelection.exit().remove()

      labelSelection.enter()
        .append('text')
        .attr('class', 'node-label')
        .text(d => d.label)

      labelSelection.text(d => d.label)

      // Restart simulation
      simulation.alpha(SIMULATION_ALPHA_FULL).restart()
    }

    function dragStarted(event, d) {
      if (!event.active) simulation.alphaTarget(SIMULATION_ALPHA_FULL).restart()
      d.fx = d.x
      d.fy = d.y
    }

    function dragged(event, d) {
      d.fx = event.x
      d.fy = event.y
    }

    function dragEnded(event, d) {
      if (!event.active) simulation.alphaTarget(0)
      d.fx = null
      d.fy = null
    }

    // Tooltip functions
    const tooltip = document.getElementById('tooltip')

    function showTooltip(event, d) {
      let content = `<div class="tooltip-title">${d.label || d.id}</div>`

      if (d.nodeType === NODE_TYPE_NODE || d.nodeType === NODE_TYPE_GATE) {
        content += `<div class="tooltip-row"><span class="tooltip-label">Type:</span> ${d.nodeType}</div>`
        if (d.advertiseAddr) {
          content += `<div class="tooltip-row"><span class="tooltip-label">Address:</span> ${d.advertiseAddr}</div>`
        }
      } else {
        content += `<div class="tooltip-row"><span class="tooltip-label">Type:</span> ${d.type || 'Object'}</div>`
        if (d.shardId !== undefined) {
          content += `<div class="tooltip-row"><span class="tooltip-label">Shard:</span> ${d.shardId}</div>`
        }
        if (d.goverseNodeId) {
          content += `<div class="tooltip-row"><span class="tooltip-label">Node:</span> ${d.goverseNodeId}</div>`
        }
      }

      tooltip.innerHTML = content
      tooltip.classList.add('visible')
    }

    function moveTooltip(event) {
      tooltip.style.left = (event.pageX + 15) + 'px'
      tooltip.style.top = (event.pageY + 15) + 'px'
    }

    function hideTooltip() {
      tooltip.classList.remove('visible')
    }

    // Update sidebar node list
    function updateNodeList() {
      const nodeList = document.getElementById('node-list')
      nodeList.innerHTML = ''

      // Add nodes
      graphData.goverse_nodes.forEach(node => {
        const li = document.createElement('li')
        li.className = 'node-item'
        const typeClass = 'node'
        li.innerHTML = `
          <div class="node-id">
            ${node.id}
            <span class="node-type ${typeClass}">${typeClass}</span>
          </div>
          <div class="node-details">
            ${node.advertise_addr ? `Address: ${node.advertise_addr}<br>` : ''}
            ${node.label && node.label !== node.id ? `Label: ${node.label}` : ''}
          </div>
        `

        li.addEventListener('click', () => {
          focusOnNode(node.id)
        })

        nodeList.appendChild(li)
      })

      // Add gates
      graphData.goverse_gates.forEach(gate => {
        const li = document.createElement('li')
        li.className = 'node-item'
        const typeClass = 'gate'
        li.innerHTML = `
          <div class="node-id">
            ${gate.id}
            <span class="node-type ${typeClass}">${typeClass}</span>
          </div>
          <div class="node-details">
            ${gate.advertise_addr ? `Address: ${gate.advertise_addr}<br>` : ''}
            ${gate.label && gate.label !== gate.id ? `Label: ${gate.label}` : ''}
          </div>
        `

        li.addEventListener('click', () => {
          focusOnNode(gate.id)
        })

        nodeList.appendChild(li)
      })
    }

    function focusOnNode(nodeId) {
      const node = simulation.nodes().find(n => n.id === nodeId)
      if (node) {
        const container = document.getElementById('graph-container')
        const width = container.clientWidth
        const height = container.clientHeight

        svg.transition().duration(750).call(
          zoom.transform,
          d3.zoomIdentity
            .translate(width / 2, height / 2)
            .scale(1.5)
            .translate(-node.x, -node.y)
        )
      }
    }

    // Shard distribution view
    function updateShardView() {
      const container = document.getElementById('shard-container')

      // Calculate stats
      const objects = graphData.goverse_objects
      const nodes = graphData.goverse_nodes
      const gates = graphData.goverse_gates

      // Group objects by shard
      const shardMap = new Map()
      objects.forEach(obj => {
        const shardId = obj.shard_id || 0
        if (!shardMap.has(shardId)) {
          shardMap.set(shardId, [])
        }
        shardMap.get(shardId).push(obj)
      })

      // Group objects by type
      const typeMap = new Map()
      objects.forEach(obj => {
        const type = obj.type || 'Unknown'
        if (!typeMap.has(type)) {
          typeMap.set(type, [])
        }
        typeMap.get(type).push(obj)
      })

      // Group objects by node
      const nodeObjMap = new Map()
      objects.forEach(obj => {
        const nodeId = obj.goverse_node_id || 'Unknown'
        if (!nodeObjMap.has(nodeId)) {
          nodeObjMap.set(nodeId, [])
        }
        nodeObjMap.get(nodeId).push(obj)
      })

      // Sort type entries alphabetically by type name (used for both legend and pie chart)
      const sortedTypes = typeMap.size > 0 
        ? Array.from(typeMap.entries()).sort((a, b) => a[0].localeCompare(b[0]))
        : []

      // Build HTML
      let html = `
        <div class="shard-stats">
          <div class="stat-card">
            <div class="stat-value">${nodes.length}</div>
            <div class="stat-label">Nodes</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${gates.length}</div>
            <div class="stat-label">Gates</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${objects.length}</div>
            <div class="stat-label">Objects</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${shardMap.size}</div>
            <div class="stat-label">Active Shards</div>
          </div>
        </div>
      `

      // Objects by type chart - using pie chart
      if (sortedTypes.length > 0) {
        html += `
          <div class="shard-chart">
            <h4>Objects by Type</h4>
            <div class="pie-chart-container">
              <svg id="objects-by-type-pie" class="pie-chart-svg" width="${PIE_CHART_SIZE}" height="${PIE_CHART_SIZE}"></svg>
              <div class="pie-chart-legend">
                ${sortedTypes.map(([type, objs]) => `
                  <div class="legend-item">
                    <div class="legend-color" style="background: ${typeColors[type] || typeColors.default}"></div>
                    <span>${type}: ${objs.length}</span>
                  </div>
                `).join('')}
              </div>
            </div>
          </div>
        `
      }

      // Objects by node chart
      if (nodeObjMap.size > 0) {
        // Sort node entries by node ID
        const sortedNodes = Array.from(nodeObjMap.entries()).sort((a, b) => a[0].localeCompare(b[0]))
        html += `
          <div class="shard-chart">
            <h4>Objects by Node</h4>
            <div class="legend">
              ${sortedNodes.map(([nodeId]) => `
                <div class="legend-item">
                  <div class="legend-color" style="background: ${typeColors.node}"></div>
                  <span>${nodeId}</span>
                </div>
              `).join('')}
            </div>
            <div class="shard-bar-container">
              ${sortedNodes.map(([nodeId, objs]) => `
                <div class="shard-bar" 
                     style="background: ${typeColors.node}; width: ${Math.max(30, objs.length * 3)}px"
                     title="${nodeId}: ${objs.length} objects">
                </div>
              `).join('')}
            </div>
          </div>
        `
      }

      // Shard distribution chart
      if (shardMap.size > 0) {
        const sortedShards = Array.from(shardMap.entries()).sort((a, b) => a[0] - b[0])
        const maxObjects = Math.max(...sortedShards.map(([_, objs]) => objs.length))

        html += `
          <div class="shard-chart">
            <h4>Shard Distribution</h4>
            <div class="shard-distribution-container">
              ${sortedShards.map(([shardId, objs]) => {
                const height = Math.max(8, (objs.length / maxObjects) * 40)
                const color = typeColors.node
                return `
                  <div class="shard-bar" 
                       style="background: ${color}; height: ${height}px; width: 12px; align-self: flex-end;"
                       title="Shard ${shardId}: ${objs.length} objects">
                  </div>
                `
              }).join('')}
            </div>
            <div class="shard-range-label">
              Shards: ${sortedShards[0]?.[0] || 0} - ${sortedShards[sortedShards.length - 1]?.[0] || 0}
            </div>
          </div>
        `
      }

      container.innerHTML = html

      // Render pie chart for Objects by Type using D3.js
      if (sortedTypes.length > 0) {
        const pieData = sortedTypes.map(([type, objs]) => ({
          type: type,
          count: objs.length,
          color: typeColors[type] || typeColors.default
        }))

        const radius = PIE_CHART_SIZE / 2

        const pieSvg = d3.select('#objects-by-type-pie')
        pieSvg.selectAll('*').remove()

        const pieG = pieSvg
          .append('g')
          .attr('transform', `translate(${PIE_CHART_SIZE / 2}, ${PIE_CHART_SIZE / 2})`)

        // Use .sort(null) to preserve alphabetical order from sortedTypes (matching legend order)
        const pie = d3.pie()
          .value(d => d.count)
          .sort(null)

        const arc = d3.arc()
          .innerRadius(0)
          .outerRadius(radius - 10)

        const arcs = pieG.selectAll('.arc')
          .data(pie(pieData))
          .enter()
          .append('g')
          .attr('class', 'arc')

        arcs.append('path')
          .attr('d', arc)
          .attr('fill', d => d.data.color)
          .attr('stroke', 'white')
          .attr('stroke-width', 2)
          .style('cursor', 'pointer')
          .on('mouseover', function(event, d) {
            d3.select(this).attr('opacity', 0.8)
            const content = `<div class="tooltip-title">${d.data.type}</div>
              <div class="tooltip-row"><span class="tooltip-label">Count:</span> ${d.data.count}</div>`
            tooltip.innerHTML = content
            tooltip.classList.add('visible')
            tooltip.style.left = (event.pageX + 15) + 'px'
            tooltip.style.top = (event.pageY + 15) + 'px'
          })
          .on('mousemove', function(event) {
            tooltip.style.left = (event.pageX + 15) + 'px'
            tooltip.style.top = (event.pageY + 15) + 'px'
          })
          .on('mouseout', function() {
            d3.select(this).attr('opacity', 1)
            tooltip.classList.remove('visible')
          })
      }
    }

    // Update nodes-only view
    function updateNodesView() {
      if (!nodesViewInitialized) {
        initNodesView()
      }

      // Build nodes array: only cluster nodes and gates (no objects)
      const nodes = []
      const nodeMap = new Map()
      const addrToNodeId = new Map() // Map advertise_addr to node id for link resolution

      graphData.goverse_nodes.forEach(n => {
        const node = {
          id: n.id,
          label: n.label || n.id,
          nodeType: NODE_TYPE_NODE,
          advertiseAddr: n.advertise_addr,
          color: n.color,
          objectCount: n.object_count || 0,
          connectedNodes: n.connected_nodes || []
        }
        nodes.push(node)
        nodeMap.set(n.id, node)
        if (n.advertise_addr) {
          addrToNodeId.set(n.advertise_addr, n.id)
        }
      })

      graphData.goverse_gates.forEach(g => {
        const node = {
          id: g.id,
          label: g.label || g.id,
          nodeType: NODE_TYPE_GATE,
          advertiseAddr: g.advertise_addr,
          color: g.color,
          objectCount: 0,
          connectedNodes: []
        }
        nodes.push(node)
        nodeMap.set(g.id, node)
      })

      // Build links array from connected_nodes
      // Use a Set to avoid duplicate links (A->B and B->A should only create one link)
      const linkSet = new Set()
      const links = []
      graphData.goverse_nodes.forEach(n => {
        const connectedNodes = n.connected_nodes || []
        connectedNodes.forEach(targetAddr => {
          // Resolve target address to node id
          const targetId = addrToNodeId.get(targetAddr) || targetAddr
          // Only create link if target node exists
          if (nodeMap.has(targetId)) {
            // Create a unique key for this link (sorted to avoid A-B and B-A duplicates)
            const linkKey = [n.id, targetId].sort().join('|')
            if (!linkSet.has(linkKey)) {
              linkSet.add(linkKey)
              links.push({
                source: n.id,
                target: targetId
              })
            }
          }
        })
      })

      // Update simulation with nodes and links
      nodesSimulation.nodes(nodes)
      nodesSimulation.force('link').links(links)

      // Update links
      const linkSelection = nodesG.select('.nodes-only-links')
        .selectAll('.nodes-link')
        .data(links, d => `${d.source.id || d.source}-${d.target.id || d.target}`)

      linkSelection.exit().remove()

      linkSelection.enter()
        .append('line')
        .attr('class', 'nodes-link')
        .attr('stroke', '#666')
        .attr('stroke-width', 2)
        .attr('stroke-opacity', 0.6)

      // Update nodes
      const nodeSelection = nodesG.select('.nodes-only-nodes')
        .selectAll('.graph-node')
        .data(nodes, d => d.id)

      nodeSelection.exit().remove()

      const nodeEnter = nodeSelection.enter()
        .append('g')
        .attr('class', 'graph-node')
        .call(d3.drag()
          .on('start', nodesViewDragStarted)
          .on('drag', nodesViewDragged)
          .on('end', nodesViewDragEnded))
        .on('mouseover', showNodesViewTooltip)
        .on('mousemove', moveTooltip)
        .on('mouseout', hideTooltip)

      // Add shapes based on node type - larger for nodes view
      nodeEnter.each(function(d) {
        const el = d3.select(this)
        const r = 40 // Larger radius for nodes-only view
        const shape = getNodeShape(d)

        if (shape === 'square') {
          el.append('rect')
            .attr('width', r * 2)
            .attr('height', r * 2)
            .attr('x', -r)
            .attr('y', -r)
            .attr('rx', 6)
            .attr('fill', getNodeColor(d))
        } else if (shape === 'diamond') {
          el.append('polygon')
            .attr('points', `0,${-r} ${r},0 0,${r} ${-r},0`)
            .attr('fill', getNodeColor(d))
        }

        // Add object count badge inside the node
        el.append('text')
          .attr('class', 'object-count-badge')
          .attr('y', 0)
          .text(d.objectCount)
      })

      // Update existing nodes
      nodeSelection.each(function(d) {
        const el = d3.select(this)
        el.select('.object-count-badge').text(d.objectCount)
      })

      // Merge enter and update selections
      const allNodes = nodeEnter.merge(nodeSelection)

      // Update labels
      const labelSelection = nodesG.select('.nodes-only-labels')
        .selectAll('.node-label')
        .data(nodes, d => d.id)

      labelSelection.exit().remove()

      labelSelection.enter()
        .append('text')
        .attr('class', 'node-label')
        .text(d => d.label)

      labelSelection.text(d => d.label)

      // Restart simulation
      nodesSimulation.alpha(SIMULATION_ALPHA_FULL).restart()
    }

    function nodesViewDragStarted(event, d) {
      if (!event.active) nodesSimulation.alphaTarget(SIMULATION_ALPHA_FULL).restart()
      d.fx = d.x
      d.fy = d.y
    }

    function nodesViewDragged(event, d) {
      d.fx = event.x
      d.fy = event.y
    }

    function nodesViewDragEnded(event, d) {
      if (!event.active) nodesSimulation.alphaTarget(0)
      d.fx = null
      d.fy = null
    }

    function showNodesViewTooltip(event, d) {
      let content = `<div class="tooltip-title">${d.label || d.id}</div>`
      content += `<div class="tooltip-row"><span class="tooltip-label">Type:</span> ${d.nodeType}</div>`
      if (d.advertiseAddr) {
        content += `<div class="tooltip-row"><span class="tooltip-label">Address:</span> ${d.advertiseAddr}</div>`
      }
      content += `<div class="tooltip-row"><span class="tooltip-label">Objects:</span> ${d.objectCount}</div>`
      if (d.connectedNodes && d.connectedNodes.length > 0) {
        content += `<div class="tooltip-row"><span class="tooltip-label">Connected to:</span> ${d.connectedNodes.length} nodes</div>`
      }

      tooltip.innerHTML = content
      tooltip.classList.add('visible')
    }

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'))
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'))

        tab.classList.add('active')
        const viewId = tab.dataset.view + '-view'
        document.getElementById(viewId).classList.add('active')

        if (tab.dataset.view === 'shard') {
          updateShardView()
        } else if (tab.dataset.view === 'nodes') {
          updateNodesView()
        }
      })
    })

    // Fetch and refresh data
    async function refresh() {
      try {
        const res = await fetch('/graph', { cache: 'no-cache' })
        const data = await res.json()
        graphData = {
          goverse_nodes: data.goverse_nodes || [],
          goverse_gates: data.goverse_gates || [],
          goverse_objects: data.goverse_objects || []
        }
        console.log('Graph data:', graphData)

        updateNodeList()
        updateGraph()

        // Update shard view if visible
        if (document.getElementById('shard-view').classList.contains('active')) {
          updateShardView()
        }
        // Update nodes view if visible
        if (document.getElementById('nodes-view').classList.contains('active')) {
          updateNodesView()
        }
      } catch (err) {
        console.error('Failed to fetch graph data from /graph:', err.message || err)
      }
    }

    // SSE connection state
    let eventSource = null
    let reconnectTimeout = null

    // Connect to SSE for push updates
    function connectSSE() {
      if (eventSource) {
        eventSource.close()
      }

      console.log('Connecting to SSE...')
      eventSource = new EventSource('/events/stream')

      eventSource.addEventListener('initial', (event) => {
        const data = JSON.parse(event.data)
        console.log('SSE initial state received:', data)
        graphData = {
          goverse_nodes: data.goverse_nodes || [],
          goverse_gates: data.goverse_gates || [],
          goverse_objects: data.goverse_objects || []
        }
        updateNodeList()
        updateGraph()
        if (document.getElementById('shard-view').classList.contains('active')) {
          updateShardView()
        }
        if (document.getElementById('nodes-view').classList.contains('active')) {
          updateNodesView()
        }
      })

      eventSource.addEventListener('node_added', (event) => {
        const data = JSON.parse(event.data)
        console.log('SSE node_added:', data)
        if (data.node) {
          upsertNode(data.node)
          updateNodeList()
          updateGraphIncremental()
          if (document.getElementById('nodes-view').classList.contains('active')) {
            updateNodesView()
          }
        }
      })

      eventSource.addEventListener('node_updated', (event) => {
        const data = JSON.parse(event.data)
        console.log('SSE node_updated:', data)
        if (data.node) {
          upsertNode(data.node)
          updateNodeList()
          if (document.getElementById('nodes-view').classList.contains('active')) {
            updateNodesView()
          }
        }
      })

      eventSource.addEventListener('node_removed', (event) => {
        const data = JSON.parse(event.data)
        console.log('SSE node_removed:', data)
        if (data.node_id) {
          graphData.goverse_nodes = graphData.goverse_nodes.filter(n => n.id !== data.node_id)
          updateNodeList()
          updateGraphIncremental()
          if (document.getElementById('nodes-view').classList.contains('active')) {
            updateNodesView()
          }
        }
      })

      eventSource.addEventListener('gate_added', (event) => {
        const data = JSON.parse(event.data)
        console.log('SSE gate_added:', data)
        if (data.gate) {
          upsertGate(data.gate)
          updateNodeList()
          updateGraphIncremental()
          if (document.getElementById('nodes-view').classList.contains('active')) {
            updateNodesView()
          }
        }
      })

      eventSource.addEventListener('gate_updated', (event) => {
        const data = JSON.parse(event.data)
        console.log('SSE gate_updated:', data)
        if (data.gate) {
          upsertGate(data.gate)
          updateNodeList()
          updateGraphIncremental()
          if (document.getElementById('nodes-view').classList.contains('active')) {
            updateNodesView()
          }
        }
      })

      eventSource.addEventListener('gate_removed', (event) => {
        const data = JSON.parse(event.data)
        console.log('SSE gate_removed:', data)
        if (data.gate_id) {
          graphData.goverse_gates = graphData.goverse_gates.filter(g => g.id !== data.gate_id)
          updateNodeList()
          updateGraphIncremental()
          if (document.getElementById('nodes-view').classList.contains('active')) {
            updateNodesView()
          }
        }
      })

      eventSource.addEventListener('object_added', (event) => {
        const data = JSON.parse(event.data)
        console.log('SSE object_added:', data)
        if (data.object) {
          upsertObject(data.object)
          updateGraphIncremental()
          if (document.getElementById('shard-view').classList.contains('active')) {
            updateShardView()
          }
          if (document.getElementById('nodes-view').classList.contains('active')) {
            updateNodesView()
          }
        }
      })

      eventSource.addEventListener('object_updated', (event) => {
        const data = JSON.parse(event.data)
        console.log('SSE object_updated:', data)
        if (data.object) {
          upsertObject(data.object)
          // No need to restart simulation for updates
        }
      })

      eventSource.addEventListener('object_removed', (event) => {
        const data = JSON.parse(event.data)
        console.log('SSE object_removed:', data)
        if (data.object_id) {
          graphData.goverse_objects = graphData.goverse_objects.filter(o => o.id !== data.object_id)
          updateGraphIncremental()
          if (document.getElementById('shard-view').classList.contains('active')) {
            updateShardView()
          }
          if (document.getElementById('nodes-view').classList.contains('active')) {
            updateNodesView()
          }
        }
      })

      eventSource.addEventListener('heartbeat', (event) => {
        console.log('SSE heartbeat received')
      })

      eventSource.onerror = (error) => {
        console.error('SSE error:', error)
        if (eventSource.readyState === EventSource.CLOSED) {
          console.log(`SSE connection closed, reconnecting in ${SSE_RECONNECT_DELAY / 1000} seconds...`)
          if (reconnectTimeout) clearTimeout(reconnectTimeout)
          reconnectTimeout = setTimeout(connectSSE, SSE_RECONNECT_DELAY)
        }
      }

      eventSource.onopen = () => {
        console.log('SSE connection established')
      }
    }

    // Incremental graph update - preserves node positions
    function updateGraphIncremental() {
      // Get current nodes from simulation to preserve positions
      const currentNodes = simulation.nodes()
      const positionMap = new Map()
      currentNodes.forEach(n => {
        positionMap.set(n.id, { x: n.x, y: n.y, vx: n.vx, vy: n.vy, fx: n.fx, fy: n.fy })
      })

      // Build nodes array: cluster nodes/gates + objects
      const nodes = []
      const links = []
      const nodeMap = new Map()

      // Add cluster nodes (nodes and gates)
      graphData.goverse_nodes.forEach(n => {
        const existingPos = positionMap.get(n.id)
        const node = {
          id: n.id,
          label: n.label || n.id,
          nodeType: n.type || NODE_TYPE_NODE,
          advertiseAddr: n.advertise_addr,
          color: n.color,
          // Preserve position if exists
          x: existingPos ? existingPos.x : undefined,
          y: existingPos ? existingPos.y : undefined,
          vx: existingPos ? existingPos.vx : undefined,
          vy: existingPos ? existingPos.vy : undefined,
          fx: existingPos ? existingPos.fx : undefined,
          fy: existingPos ? existingPos.fy : undefined
        }
        nodes.push(node)
        nodeMap.set(n.id, node)
      })

      // Add objects
      graphData.goverse_objects.forEach(obj => {
        const existingPos = positionMap.get(obj.id)
        const node = {
          id: obj.id,
          label: obj.label || obj.id,
          nodeType: NODE_TYPE_OBJECT,
          type: obj.type,
          shardId: obj.shard_id,
          goverseNodeId: obj.goverse_node_id,
          color: obj.color,
          size: obj.size,
          // Preserve position if exists
          x: existingPos ? existingPos.x : undefined,
          y: existingPos ? existingPos.y : undefined,
          vx: existingPos ? existingPos.vx : undefined,
          vy: existingPos ? existingPos.vy : undefined,
          fx: existingPos ? existingPos.fx : undefined,
          fy: existingPos ? existingPos.fy : undefined
        }
        nodes.push(node)
        nodeMap.set(obj.id, node)

        // Create link from object to its node
        if (obj.goverse_node_id && nodeMap.has(obj.goverse_node_id)) {
          links.push({
            source: obj.id,
            target: obj.goverse_node_id
          })
        }
      })

      // Update simulation with low alpha to minimize movement
      simulation.nodes(nodes)
      simulation.force('link').links(links)

      // Update links
      const linkSelection = g.select('.links')
        .selectAll('.graph-link')
        .data(links, d => `${d.source.id || d.source}-${d.target.id || d.target}`)

      linkSelection.exit().remove()

      linkSelection.enter()
        .append('line')
        .attr('class', 'graph-link')
        .attr('stroke-width', 1.5)

      // Update nodes
      const nodeSelection = g.select('.nodes')
        .selectAll('.graph-node')
        .data(nodes, d => d.id)

      nodeSelection.exit().remove()

      const nodeEnter = nodeSelection.enter()
        .append('g')
        .attr('class', 'graph-node')
        .call(d3.drag()
          .on('start', dragStarted)
          .on('drag', dragged)
          .on('end', dragEnded))
        .on('mouseover', showTooltip)
        .on('mousemove', moveTooltip)
        .on('mouseout', hideTooltip)

      // Add shapes based on node type
      nodeEnter.each(function(d) {
        const el = d3.select(this)
        const r = getNodeRadius(d)
        const shape = getNodeShape(d)

        if (shape === 'square') {
          el.append('rect')
            .attr('width', r * 2)
            .attr('height', r * 2)
            .attr('x', -r)
            .attr('y', -r)
            .attr('rx', 4)
            .attr('fill', getNodeColor(d))
        } else if (shape === 'diamond') {
          el.append('polygon')
            .attr('points', `0,${-r} ${r},0 0,${r} ${-r},0`)
            .attr('fill', getNodeColor(d))
        } else {
          el.append('circle')
            .attr('r', r)
            .attr('fill', getNodeColor(d))
        }
      })

      // Update existing node colors
      nodeSelection.each(function(d) {
        const el = d3.select(this)
        const shape = getNodeShape(d)
        if (shape === 'square') {
          el.select('rect').attr('fill', getNodeColor(d))
        } else if (shape === 'diamond') {
          el.select('polygon').attr('fill', getNodeColor(d))
        } else {
          el.select('circle').attr('fill', getNodeColor(d))
        }
      })

      // Update labels
      const labelSelection = g.select('.labels')
        .selectAll('.node-label')
        .data(nodes.filter(d => d.nodeType === NODE_TYPE_NODE || d.nodeType === NODE_TYPE_GATE), d => d.id)

      labelSelection.exit().remove()

      labelSelection.enter()
        .append('text')
        .attr('class', 'node-label')
        .text(d => d.label)

      labelSelection.text(d => d.label)

      // Use very low alpha to minimize disruption
      simulation.alpha(SIMULATION_ALPHA_INCREMENTAL).restart()
    }

    // Initialize
    initGraph()
    connectSSE()
  </script>
</body>
</html>

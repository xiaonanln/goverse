# GoVerse Requests Schema Guide

This guide explains the `goverse_requests` table schema designed to support **exactly-once semantics** for inter-object calls in GoVerse.

## Overview

The `goverse_requests` table provides durable storage for inter-object method calls, ensuring that each request is processed exactly once, even in the face of:
- Network failures and retries
- Node crashes and restarts
- Duplicate client requests
- Concurrent processing attempts

## Exactly-Once Semantics

### What is Exactly-Once?

In distributed systems, **exactly-once semantics** means a request is processed once and only once, regardless of how many times it's received or retried. This is achieved through:

1. **Idempotent Request Storage**: Using `request_id` as a unique key
2. **State Tracking**: Recording the processing status through the lifecycle
3. **Result Caching**: Storing results to return for duplicate requests
4. **Distributed Locking**: Using `node_id` to prevent concurrent processing

### How It Works

```
┌─────────────┐
│   Client    │
└──────┬──────┘
       │ 1. Send request with unique request_id
       ▼
┌─────────────┐
│  GoVerse    │ 2. Insert into goverse_requests (if not exists)
│    Node     │ 3. Update status: pending -> processing
└──────┬──────┘
       │ 4. Process the request
       ▼
┌─────────────┐
│   Object    │ 5. Execute method
└──────┬──────┘
       │ 6. Update status: processing -> completed/failed
       │    Store result_data or error_message
       ▼
┌─────────────┐
│  Response   │ 7. Return result (from cache if duplicate)
└─────────────┘
```

If the same `request_id` is received again:
- The system detects it already exists (PRIMARY KEY constraint)
- Returns the cached result from `result_data` if status is 'completed'
- Returns the error from `error_message` if status is 'failed'
- Waits or retries if status is 'pending' or 'processing'

## Schema Design

### Core Fields

```sql
request_id VARCHAR(255) PRIMARY KEY
```
**Purpose**: Unique identifier for deduplication  
**Generated by**: Client (UUID, ULID, or combination of caller + nonce)  
**Example**: `"req-123e4567-e89b-12d3-a456-426614174000"`

```sql
object_id VARCHAR(255) NOT NULL
object_type VARCHAR(255) NOT NULL
method_name VARCHAR(255) NOT NULL
```
**Purpose**: Identify the target object and method  
**Example**: `object_id="Counter-user123"`, `object_type="Counter"`, `method_name="Add"`

```sql
request_data BYTEA NOT NULL
```
**Purpose**: Serialized request parameters  
**Format**: Typically protobuf-encoded message  
**Example**: `protobuf.Marshal(&wrapperspb.Int32Value{Value: 5})`

### Result Fields

```sql
result_data BYTEA
```
**Purpose**: Serialized response (populated when status = 'completed')  
**Format**: Typically protobuf-encoded message  
**Constraint**: Must be NOT NULL when status = 'completed'

```sql
error_message TEXT
```
**Purpose**: Human-readable error description (populated when status = 'failed')  
**Example**: `"Division by zero error in Calculate method"`  
**Constraint**: Must be NOT NULL when status = 'failed'

### Status Management

```sql
status VARCHAR(50) NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'processing', 'completed', 'failed'))
```

**Status State Machine**:
```
   pending ──────────> processing ──────────> completed
      │                    │                       ▲
      │                    │                       │
      │                    └──────> failed         │
      │                                            │
      └────────────────────────────────────────────┘
                  (if result cached)
```

**Status Meanings**:
- `pending`: Request received but not yet being processed
- `processing`: Actively being processed by a node (locked via `node_id`)
- `completed`: Successfully processed, `result_data` contains the response
- `failed`: Processing failed, `error_message` contains the error details

### Distributed Locking

```sql
node_id VARCHAR(255)
```
**Purpose**: Identify which node is currently processing the request  
**Usage**:
1. When a node starts processing, it sets `node_id` to its own ID
2. Only requests with matching `node_id` can be updated by that node
3. If a node crashes, stuck requests are detected and recovered

**Recovery Pattern**:
```sql
-- Find stuck requests for a specific node
SELECT * FROM goverse_requests 
WHERE node_id = 'crashed-node-id' AND status = 'processing';

-- Mark them as failed
UPDATE goverse_requests 
SET status = 'failed', 
    error_message = 'Node crashed during processing'
WHERE node_id = 'crashed-node-id' AND status = 'processing';
```

### Retry Tracking

```sql
retry_count INTEGER NOT NULL DEFAULT 0
```
**Purpose**: Track how many times a request has been retried  
**Usage**: Increment on each retry attempt for monitoring and circuit breaking

### Timestamps

```sql
created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
processed_at TIMESTAMP
expires_at TIMESTAMP
```

**Timestamp Purposes**:
- `created_at`: When the request was first received (never changes)
- `updated_at`: Last modification time (auto-updated by trigger)
- `processed_at`: When processing completed (status became completed/failed)
- `expires_at`: When the request should be cleaned up (optional TTL)

### Caller Information

```sql
caller_object_id VARCHAR(255)
caller_client_id VARCHAR(255)
```
**Purpose**: Track the originator for debugging and tracing  
**Usage**: Populated if the call came from another object or a specific client

## Indexes

### Primary Lookup Index
```sql
CREATE INDEX idx_goverse_requests_object_status 
    ON goverse_requests(object_id, status);
```
**Use Case**: Find all pending/processing requests for a specific object

### Cleanup Index
```sql
CREATE INDEX idx_goverse_requests_expires_at 
    ON goverse_requests(expires_at) 
    WHERE expires_at IS NOT NULL;
```
**Use Case**: Efficiently delete expired requests in background jobs

### Monitoring Index
```sql
CREATE INDEX idx_goverse_requests_status_created 
    ON goverse_requests(status, created_at);
```
**Use Case**: Find old pending/processing requests (stuck detection)

### Node Recovery Index
```sql
CREATE INDEX idx_goverse_requests_node_status 
    ON goverse_requests(node_id, status) 
    WHERE node_id IS NOT NULL;
```
**Use Case**: Find all requests being processed by a specific node

### Active Requests Index
```sql
CREATE INDEX idx_goverse_requests_active 
    ON goverse_requests(request_id, object_id) 
    WHERE status IN ('pending', 'processing');
```
**Use Case**: Fast lookups for active requests (performance optimization)

## Helper Functions

### Automatic Timestamp Update

```sql
CREATE TRIGGER trigger_update_goverse_requests_timestamp
    BEFORE UPDATE ON goverse_requests
    FOR EACH ROW
    EXECUTE FUNCTION update_goverse_requests_timestamp();
```

This trigger automatically updates `updated_at` on every row modification.

### Cleanup Expired Requests

```sql
SELECT cleanup_expired_requests();
```

**Returns**: Number of deleted requests  
**Recommended**: Call this periodically (e.g., every hour) via a background job

**Example**:
```sql
-- Delete requests that expired more than 1 hour ago
SELECT cleanup_expired_requests();
-- Returns: 42 (deleted 42 expired requests)
```

### Mark Stuck Requests as Failed

```sql
SELECT mark_stuck_requests_as_failed('5 minutes'::interval);
```

**Returns**: Number of requests marked as failed  
**Recommended**: Call this periodically (e.g., every minute) to handle node failures

**Example**:
```sql
-- Mark requests stuck in 'processing' for more than 5 minutes as failed
SELECT mark_stuck_requests_as_failed('5 minutes'::interval);
-- Returns: 3 (marked 3 stuck requests as failed)
```

## Usage Patterns

### 1. Submitting a New Request

```go
import (
    "database/sql"
    "github.com/google/uuid"
)

func SubmitRequest(ctx context.Context, db *sql.DB, 
    objectID, objectType, method string, 
    requestData []byte) (string, error) {
    
    requestID := uuid.New().String()
    expiresAt := time.Now().Add(24 * time.Hour)
    
    // Track retry attempts by incrementing retry_count on conflict
    _, err := db.ExecContext(ctx, `
        INSERT INTO goverse_requests 
            (request_id, object_id, object_type, method_name, 
             request_data, expires_at)
        VALUES ($1, $2, $3, $4, $5, $6)
        ON CONFLICT (request_id) DO UPDATE 
        SET retry_count = goverse_requests.retry_count + 1
    `, requestID, objectID, objectType, method, requestData, expiresAt)
    
    return requestID, err
}
```

### 2. Processing a Request

```go
func ProcessRequest(ctx context.Context, db *sql.DB, 
    requestID, nodeID string) error {
    
    // 1. Atomically claim the request (prevents race condition)
    // Only update if status is 'pending' to ensure only one node processes
    result, err := db.ExecContext(ctx, `
        UPDATE goverse_requests
        SET status = 'processing',
            node_id = $2
        WHERE request_id = $1 
          AND status = 'pending'
    `, requestID, nodeID)
    
    if err != nil {
        return err
    }
    
    rows, _ := result.RowsAffected()
    if rows == 0 {
        // Already being processed or completed
        return ErrAlreadyProcessed
    }
    
    // 2. Get request details
    var objectID, objectType, methodName string
    var requestData []byte
    err = db.QueryRowContext(ctx, `
        SELECT object_id, object_type, method_name, request_data
        FROM goverse_requests
        WHERE request_id = $1
    `, requestID).Scan(&objectID, &objectType, &methodName, &requestData)
    
    // 3. Execute the method (application-specific)
    resultData, err := ExecuteMethod(objectID, objectType, methodName, requestData)
    
    // 4. Update with result or error
    // Only update if still in 'processing' state and node_id matches (prevents unauthorized updates)
    if err != nil {
        _, err = db.ExecContext(ctx, `
            UPDATE goverse_requests
            SET status = 'failed',
                error_message = $2,
                processed_at = CURRENT_TIMESTAMP
            WHERE request_id = $1 
              AND node_id = $3 
              AND status = 'processing'
        `, requestID, err.Error(), nodeID)
    } else {
        _, err = db.ExecContext(ctx, `
            UPDATE goverse_requests
            SET status = 'completed',
                result_data = $2,
                processed_at = CURRENT_TIMESTAMP
            WHERE request_id = $1 
              AND node_id = $3 
              AND status = 'processing'
        `, requestID, resultData, nodeID)
    }
    
    return err
}
```

### 3. Checking Request Status

```go
func GetRequestStatus(ctx context.Context, db *sql.DB, 
    requestID string) (status string, resultData []byte, errMsg string, err error) {
    
    err = db.QueryRowContext(ctx, `
        SELECT status, result_data, error_message
        FROM goverse_requests
        WHERE request_id = $1
    `, requestID).Scan(&status, &resultData, &errMsg)
    
    return
}
```

### 4. Handling Retries

```go
func SubmitWithRetry(ctx context.Context, db *sql.DB, 
    requestID, objectID, objectType, method string,
    requestData []byte) error {
    
    // Check if request already exists
    var status string
    var resultData []byte
    var errorMsg string
    
    err := db.QueryRowContext(ctx, `
        SELECT status, result_data, error_message
        FROM goverse_requests
        WHERE request_id = $1
    `, requestID).Scan(&status, &resultData, &errorMsg)
    
    if err == sql.ErrNoRows {
        // New request - insert it
        _, err = db.ExecContext(ctx, `
            INSERT INTO goverse_requests 
                (request_id, object_id, object_type, method_name, request_data)
            VALUES ($1, $2, $3, $4, $5)
        `, requestID, objectID, objectType, method, requestData)
        return err
    }
    
    // Request exists - handle based on status
    switch status {
    case "completed":
        // Return cached result
        return nil // or return resultData
    case "failed":
        // Could retry or return error
        return fmt.Errorf("previous attempt failed: %s", errorMsg)
    case "pending", "processing":
        // Wait and retry
        return ErrRequestInProgress
    }
    
    return err
}
```

## Monitoring and Maintenance

### Key Metrics to Monitor

1. **Pending Request Age**
```sql
SELECT COUNT(*) as old_pending_count
FROM goverse_requests
WHERE status = 'pending' 
  AND created_at < CURRENT_TIMESTAMP - INTERVAL '5 minutes';
```

2. **Processing Time Distribution**
```sql
SELECT 
    percentile_cont(0.5) WITHIN GROUP (ORDER BY EXTRACT(EPOCH FROM (processed_at - created_at))) as p50,
    percentile_cont(0.95) WITHIN GROUP (ORDER BY EXTRACT(EPOCH FROM (processed_at - created_at))) as p95,
    percentile_cont(0.99) WITHIN GROUP (ORDER BY EXTRACT(EPOCH FROM (processed_at - created_at))) as p99
FROM goverse_requests
WHERE status IN ('completed', 'failed')
  AND processed_at IS NOT NULL;
```

3. **Failure Rate**
```sql
SELECT 
    status,
    COUNT(*) as count,
    ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER (), 2) as percentage
FROM goverse_requests
WHERE created_at > CURRENT_TIMESTAMP - INTERVAL '1 hour'
GROUP BY status;
```

### Maintenance Tasks

#### Daily Cleanup
```sql
-- Run daily to clean up old completed/failed requests
SELECT cleanup_expired_requests();
```

#### Stuck Request Recovery
```sql
-- Run every minute to detect and recover from node failures
SELECT mark_stuck_requests_as_failed('5 minutes'::interval);
```

#### Archive Old Requests
```sql
-- Archive completed requests older than 30 days to a separate table
INSERT INTO goverse_requests_archive
SELECT * FROM goverse_requests
WHERE status IN ('completed', 'failed')
  AND created_at < CURRENT_TIMESTAMP - INTERVAL '30 days';

DELETE FROM goverse_requests
WHERE status IN ('completed', 'failed')
  AND created_at < CURRENT_TIMESTAMP - INTERVAL '30 days';
```

## Security Considerations

### Access Control

Grant minimal required permissions:

```sql
-- Read/Write for the application
GRANT SELECT, INSERT, UPDATE ON goverse_requests TO goverse_app;

-- Read-only for monitoring
GRANT SELECT ON goverse_requests TO goverse_monitor;

-- Full access for admin/maintenance
GRANT ALL ON goverse_requests TO goverse_admin;
```

### Preventing SQL Injection

Always use parameterized queries:

```go
// GOOD - parameterized query
db.ExecContext(ctx, "SELECT * FROM goverse_requests WHERE request_id = $1", requestID)

// BAD - vulnerable to SQL injection
db.ExecContext(ctx, fmt.Sprintf("SELECT * FROM goverse_requests WHERE request_id = '%s'", requestID))
```

## Performance Optimization

### Connection Pooling

Configure appropriate connection pool settings:

```go
db.SetMaxOpenConns(25)
db.SetMaxIdleConns(5)
db.SetConnMaxLifetime(5 * time.Minute)
```

### Batch Operations

Process multiple requests in a transaction:

```go
tx, _ := db.BeginTx(ctx, nil)
defer tx.Rollback()

for _, req := range requests {
    tx.ExecContext(ctx, "INSERT INTO goverse_requests ...")
}

tx.Commit()
```

### Index Hints

For complex queries, ensure indexes are used:

```sql
EXPLAIN ANALYZE
SELECT * FROM goverse_requests
WHERE object_id = 'obj-123' AND status = 'pending';
```

## Migration from Best-Effort to Exactly-Once

If you're migrating an existing system:

### Phase 1: Add Schema
1. Create the `goverse_requests` table
2. Deploy the schema to all environments
3. Monitor for any issues

### Phase 2: Dual-Write
1. Write to both old and new systems
2. Read from old system (existing behavior)
3. Validate new system works correctly

### Phase 3: Dual-Read
1. Continue dual-write
2. Start reading from new system
3. Compare results with old system
4. Monitor for discrepancies

### Phase 4: Complete Migration
1. Switch completely to new system
2. Deprecate old system
3. Clean up old code and data

## Troubleshooting

### Requests Stuck in Processing

**Symptom**: Requests remain in 'processing' status for too long

**Diagnosis**:
```sql
SELECT * FROM goverse_requests
WHERE status = 'processing'
  AND updated_at < CURRENT_TIMESTAMP - INTERVAL '5 minutes';
```

**Solution**:
```sql
-- Mark as failed and retry
SELECT mark_stuck_requests_as_failed('5 minutes'::interval);
```

### High Retry Counts

**Symptom**: Many requests have high `retry_count`

**Diagnosis**:
```sql
SELECT object_id, method_name, AVG(retry_count) as avg_retries
FROM goverse_requests
GROUP BY object_id, method_name
HAVING AVG(retry_count) > 3
ORDER BY avg_retries DESC;
```

**Solution**: Investigate the underlying cause (network issues, bugs, resource constraints)

### Table Growth

**Symptom**: Table size growing unbounded

**Diagnosis**:
```sql
SELECT 
    pg_size_pretty(pg_total_relation_size('goverse_requests')) as total_size,
    COUNT(*) as row_count
FROM goverse_requests;
```

**Solution**:
- Set appropriate `expires_at` values
- Run `cleanup_expired_requests()` regularly
- Archive old completed requests

## Conclusion

The `goverse_requests` schema provides a robust foundation for implementing exactly-once semantics in GoVerse. By properly utilizing the schema, indexes, and helper functions, you can build reliable distributed systems with strong consistency guarantees.

Key takeaways:
- Use unique `request_id` for deduplication
- Track status transitions carefully
- Implement proper cleanup and monitoring
- Handle node failures gracefully
- Monitor key metrics for system health

For questions or issues, refer to the GoVerse documentation or file an issue on GitHub.
